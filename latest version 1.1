import pygame
import sys
import random
import math
import os
from pygame import gfxdraw

# Initialize Pygame
pygame.init()
pygame.font.init()

# Game constants
SCREEN_WIDTH, SCREEN_HEIGHT = 1000, 700
PLAYER_SIZE = 50
ENEMY_SIZE = 40
ITEM_SIZE = 30
FPS = 60

# Retro 80s Color Palette with expanded colors for effects
BACKGROUND = (10, 10, 30)
UI_BG = (20, 15, 40)
UI_BORDER = (255, 105, 180)  # Hot pink
TEXT_COLOR = (0, 255, 255)   # Cyan
PLAYER_COLOR = (0, 255, 0)   # Green
ENEMY_COLOR = (255, 0, 0)    # Red
HEALTH_COLOR = (255, 105, 180)  # Hot pink
MANA_COLOR = (0, 255, 255)   # Cyan
EXP_COLOR = (255, 255, 0)    # Yellow
ITEM_COLOR = (255, 215, 0)   # Gold
DRAGON_COLOR = (255, 69, 0)  # Red-orange
GRID_COLOR = (50, 50, 80)    # Grid lines

# Effect colors
FIRE_COLORS = [(255, 100, 0), (255, 150, 0), (255, 200, 50)]
ICE_COLORS = [(100, 200, 255), (150, 220, 255), (200, 240, 255)]
SHADOW_COLORS = [(40, 40, 80), (70, 70, 120), (100, 100, 150)]
MAGIC_COLORS = [(150, 0, 255), (200, 50, 255), (255, 100, 255)]

# Create the screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Dragon's Lair RPG")
clock = pygame.time.Clock()

# Fonts
try:
    font_large = pygame.font.Font("freesansbold.ttf", 48)
    font_medium = pygame.font.Font("freesansbold.ttf", 32)
    font_small = pygame.font.Font("freesansbold.ttf", 24)
    font_tiny = pygame.font.Font("freesansbold.ttf", 18)
except:
    font_large = pygame.font.SysFont("Courier", 48, bold=True)
    font_medium = pygame.font.SysFont("Courier", 32, bold=True)
    font_small = pygame.font.SysFont("Courier", 24, bold=True)
    font_tiny = pygame.font.SysFont("Courier", 18, bold=True)

# Grid settings
GRID_SIZE = 50
GRID_WIDTH = SCREEN_WIDTH // GRID_SIZE
GRID_HEIGHT = SCREEN_HEIGHT // GRID_SIZE

# Particle system for effects
class Particle:
    def __init__(self, x, y, color, velocity, size, lifetime):
        self.x = x
        self.y = y
        self.color = color
        self.velocity = velocity
        self.size = size
        self.lifetime = lifetime
        self.age = 0
        
    def update(self):
        self.x += self.velocity[0]
        self.y += self.velocity[1]
        self.age += 1
        return self.age >= self.lifetime
        
    def draw(self, surface):
        alpha = 255 * (1 - self.age/self.lifetime)
        color = (*self.color[:3], int(alpha))
        radius = int(self.size * (1 - self.age/self.lifetime))
        if radius > 0:
            gfxdraw.filled_circle(surface, int(self.x), int(self.y), radius, color)

class ParticleSystem:
    def __init__(self):
        self.particles = []
        
    def add_particle(self, x, y, color, velocity, size, lifetime):
        self.particles.append(Particle(x, y, color, velocity, size, lifetime))
        
    def add_explosion(self, x, y, color, count=20, size_range=(2, 5), speed_range=(1, 3), lifetime_range=(20, 40)):
        for _ in range(count):
            angle = random.uniform(0, math.pi*2)
            speed = random.uniform(*speed_range)
            velocity = (math.cos(angle) * speed, math.sin(angle) * speed)
            size = random.uniform(*size_range)
            lifetime = random.randint(*lifetime_range)
            self.add_particle(x, y, color, velocity, size, lifetime)
            
    def add_beam(self, x1, y1, x2, y2, color, width=3, particle_count=10, speed=2):
        dx = x2 - x1
        dy = y2 - y1
        distance = math.sqrt(dx*dx + dy*dy)
        steps = max(1, int(distance / 5))
        
        for i in range(steps):
            px = x1 + (dx * i/steps)
            py = y1 + (dy * i/steps)
            for _ in range(particle_count):
                angle = random.uniform(0, math.pi*2)
                velocity = (math.cos(angle) * 0.2, math.sin(angle) * 0.2)
                self.add_particle(px, py, color, velocity, width, 15)
    
    def update(self):
        self.particles = [p for p in self.particles if not p.update()]
        
    def draw(self, surface):
        for particle in self.particles:
            particle.draw(surface)

class Button:
    def __init__(self, x, y, width, height, text, color=UI_BORDER, hover_color=(255, 215, 0)):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.hover_color = hover_color
        self.current_color = color
        self.text_surf = font_medium.render(text, True, TEXT_COLOR)
        self.text_rect = self.text_surf.get_rect(center=self.rect.center)
        self.glow = 0
        self.glow_dir = 1
        self.selected = False
        
    def draw(self, surface):
        if self.glow > 0 or self.selected:
            glow_radius = max(self.glow, 8 if self.selected else 0)
            glow_surf = pygame.Surface((self.rect.width + glow_radius*2, self.rect.height + glow_radius*2), pygame.SRCALPHA)
            pygame.draw.rect(glow_surf, (*self.current_color[:3], 50), glow_surf.get_rect(), border_radius=12)
            surface.blit(glow_surf, (self.rect.x - glow_radius, self.rect.y - glow_radius))
        
        pygame.draw.rect(surface, UI_BG, self.rect, border_radius=8)
        
        border_color = (255, 215, 0) if self.selected else self.current_color
        border_width = 4 if self.selected else 3
        pygame.draw.rect(surface, border_color, self.rect, border_width, border_radius=8)
        
        surface.blit(self.text_surf, self.text_rect)
        
    def update(self, mouse_pos):
        if self.rect.collidepoint(mouse_pos):
            self.current_color = self.hover_color
            self.glow = min(self.glow + 2, 10)
            return True
        else:
            self.current_color = self.color
            self.glow = max(self.glow - 1, 0)
        return False
        
    def is_clicked(self, mouse_pos, mouse_click):
        return self.rect.collidepoint(mouse_pos) and mouse_click

class Character:
    def __init__(self, char_type="Warrior"):
        self.type = char_type
        self.level = 1
        self.exp = 0
        self.exp_to_level = 100
        
        if char_type == "Warrior":
            self.max_health = 120
            self.max_mana = 50
            self.strength = 15
            self.defense = 10
            self.speed = 7
        elif char_type == "Mage":
            self.max_health = 80
            self.max_mana = 120
            self.strength = 8
            self.defense = 6
            self.speed = 8
        else:  # Rogue
            self.max_health = 100
            self.max_mana = 70
            self.strength = 12
            self.defense = 8
            self.speed = 12
            
        self.health = self.max_health
        self.mana = self.max_mana
        self.x = SCREEN_WIDTH // 2
        self.y = SCREEN_HEIGHT // 2
        self.attack_cooldown = 0
        self.kills = 0
        self.items_collected = 0
        self.animation_offset = 0
        self.attack_animation = 0
        self.hit_animation = 0
        
    def move(self, dx, dy):
        new_x = self.x + dx * GRID_SIZE
        new_y = self.y + dy * GRID_SIZE
        
        if 0 <= new_x < SCREEN_WIDTH:
            self.x = new_x
        if 0 <= new_y < SCREEN_HEIGHT:
            self.y = new_y
            
    def update_animation(self):
        # Idle bobbing animation
        self.animation_offset = math.sin(pygame.time.get_ticks() * 0.005) * 2
        
        # Attack animation
        if self.attack_animation > 0:
            self.attack_animation -= 1
            
        # Hit reaction animation
        if self.hit_animation > 0:
            self.hit_animation -= 1
            
    def draw(self, surface):
        offset_x = 0
        offset_y = self.animation_offset
        
        # Add attack animation offset
        if self.attack_animation > 0:
            if self.type == "Warrior":
                offset_x = 5 * math.sin(self.attack_animation * 0.2)
            elif self.type == "Mage":
                offset_y -= 5 * (1 - self.attack_animation / 10)
            else:  # Rogue
                offset_x = -5 * math.sin(self.attack_animation * 0.2)
                
        # Add hit reaction
        if self.hit_animation > 0:
            offset_x = random.randint(-2, 2)
            offset_y = random.randint(-2, 2)
        
        x = self.x + offset_x
        y = self.y + offset_y
        
        # Draw detailed character based on type
        if self.type == "Warrior":
            # Body
            pygame.draw.rect(surface, (0, 150, 0), (x, y + 10, PLAYER_SIZE, PLAYER_SIZE - 10))
            # Head
            pygame.draw.circle(surface, (240, 200, 150), (x + PLAYER_SIZE//2, y + 8), 8)
            # Shield
            pygame.draw.rect(surface, (150, 75, 0), (x + 5, y + 20, 10, 20))
            # Sword - animate when attacking
            sword_offset = 0
            if self.attack_animation > 0:
                sword_offset = -10 * (1 - self.attack_animation / 10)
            pygame.draw.rect(surface, (200, 200, 200), (x + 30 + sword_offset, y + 15, 5, 25))
            pygame.draw.polygon(surface, (200, 200, 200), 
                              [(x + 30 + sword_offset, y + 15), 
                               (x + 40 + sword_offset, y + 10),
                               (x + 35 + sword_offset, y + 15)])
            # Shoulder pads
            pygame.draw.rect(surface, (0, 100, 0), (x, y + 10, 10, 10))
            pygame.draw.rect(surface, (0, 100, 0), (x + PLAYER_SIZE - 10, y + 10, 10, 10))
            
        elif self.type == "Mage":
            # Robe
            pygame.draw.rect(surface, (0, 100, 150), (x, y + 15, PLAYER_SIZE, PLAYER_SIZE - 15))
            # Head
            pygame.draw.circle(surface, (240, 200, 150), (x + PLAYER_SIZE//2, y + 10), 10)
            # Hat - animate when attacking
            hat_offset = 0
            if self.attack_animation > 0:
                hat_offset = -5 * (1 - self.attack_animation / 10)
            pygame.draw.polygon(surface, (100, 50, 200), 
                              [(x + PLAYER_SIZE//2 - 15, y + 10 + hat_offset), 
                               (x + PLAYER_SIZE//2 + 15, y + 10 + hat_offset),
                               (x + PLAYER_SIZE//2, y - 10 + hat_offset)])
            # Staff
            staff_top_offset = 0
            if self.attack_animation > 0:
                staff_top_offset = -10 * (1 - self.attack_animation / 10)
            pygame.draw.line(surface, (180, 150, 100), (x + 10, y + 10), (x + 10, y + PLAYER_SIZE), 3)
            pygame.draw.circle(surface, (200, 200, 100), (x + 10, y + 10 + staff_top_offset), 6)
            
        else:  # Rogue
            # Body
            pygame.draw.rect(surface, (150, 0, 0), (x, y + 10, PLAYER_SIZE, PLAYER_SIZE - 10))
            # Head
            pygame.draw.circle(surface, (240, 200, 150), (x + PLAYER_SIZE//2, y + 8), 8)
            # Hood
            pygame.draw.polygon(surface, (100, 0, 0), 
                              [(x + 10, y + 15), 
                               (x + PLAYER_SIZE - 10, y + 15),
                               (x + PLAYER_SIZE//2, y - 5)])
            # Daggers - animate when attacking
            dagger_offset = 0
            if self.attack_animation > 0:
                dagger_offset = -15 * (1 - self.attack_animation / 10)
            pygame.draw.polygon(surface, (180, 180, 200), 
                              [(x + 15 + dagger_offset, y + 20), 
                               (x + 20 + dagger_offset, y + 15),
                               (x + 25 + dagger_offset, y + 20)])
            pygame.draw.polygon(surface, (180, 180, 200), 
                              [(x + PLAYER_SIZE - 15 - dagger_offset, y + 20), 
                               (x + PLAYER_SIZE - 20 - dagger_offset, y + 15),
                               (x + PLAYER_SIZE - 25 - dagger_offset, y + 20)])
            # Belt
            pygame.draw.rect(surface, (50, 50, 50), (x, y + 35, PLAYER_SIZE, 5))
    
    def start_attack_animation(self):
        self.attack_animation = 10
        
    def start_hit_animation(self):
        self.hit_animation = 5
    
    def take_damage(self, damage):
        actual_damage = max(1, damage - self.defense // 3)
        self.health -= actual_damage
        self.start_hit_animation()
        return actual_damage
    
    def gain_exp(self, amount):
        self.exp += amount
        if self.exp >= self.exp_to_level:
            self.level_up()
            
    def level_up(self):
        self.level += 1
        self.exp -= self.exp_to_level
        self.exp_to_level = int(self.exp_to_level * 1.5)
        
        self.max_health += 20
        self.max_mana += 15
        self.strength += 3
        self.defense += 2
        self.speed += 1
        
        self.health = self.max_health
        self.mana = self.max_mana
        
    def draw_stats(self, surface, x, y):
        pygame.draw.rect(surface, (20, 20, 30), (x, y, 200, 25), border_radius=3)
        health_width = 196 * (self.health / self.max_health)
        pygame.draw.rect(surface, HEALTH_COLOR, (x + 2, y + 2, health_width, 21), border_radius=3)
        health_text = font_small.render(f"HP: {self.health}/{self.max_health}", True, TEXT_COLOR)
        surface.blit(health_text, (x + 205, y + 4))
        
        pygame.draw.rect(surface, (20, 20, 30), (x, y + 30, 200, 20), border_radius=3)
        mana_width = 196 * (self.mana / self.max_mana)
        pygame.draw.rect(surface, MANA_COLOR, (x + 2, y + 32, mana_width, 16), border_radius=3)
        mana_text = font_small.render(f"MP: {self.mana}/{self.max_mana}", True, TEXT_COLOR)
        surface.blit(mana_text, (x + 205, y + 32))
        
        pygame.draw.rect(surface, (20, 20, 30), (x, y + 55, 200, 15), border_radius=3)
        exp_width = 196 * (self.exp / self.exp_to_level)
        pygame.draw.rect(surface, EXP_COLOR, (x + 2, y + 57, exp_width, 11), border_radius=3)
        exp_text = font_small.render(f"Level: {self.level}  Exp: {self.exp}/{self.exp_to_level}", True, TEXT_COLOR)
        surface.blit(exp_text, (x, y + 75))
        
        stats_text = font_small.render(f"Str: {self.strength}  Def: {self.defense}  Spd: {self.speed}", True, TEXT_COLOR)
        surface.blit(stats_text, (x, y + 100))

class Enemy:
    def __init__(self, player_level):
        self.size = ENEMY_SIZE
        self.x = random.randint(0, GRID_WIDTH-1) * GRID_SIZE
        self.y = random.randint(0, GRID_HEIGHT-1) * GRID_SIZE
        
        self.health = random.randint(20, 30) + player_level * 5
        self.max_health = self.health
        self.strength = random.randint(5, 10) + player_level * 2
        self.speed = random.randint(3, 6) + player_level // 2
        self.color = ENEMY_COLOR
        self.movement_cooldown = 0
        self.movement_delay = 60
        self.enemy_type = random.choice(["fiery", "shadow", "ice"])
        self.animation_offset = 0
        self.attack_animation = 0
        self.hit_animation = 0
        
    def update_animation(self):
        # Idle animation
        self.animation_offset = math.sin(pygame.time.get_ticks() * 0.005) * 2
        
        # Attack animation
        if self.attack_animation > 0:
            self.attack_animation -= 1
            
        # Hit reaction animation
        if self.hit_animation > 0:
            self.hit_animation -= 1
            
    def start_attack_animation(self):
        self.attack_animation = 10
        
    def start_hit_animation(self):
        self.hit_animation = 5
        
    def draw(self, surface):
        offset_x = 0
        offset_y = self.animation_offset
        
        # Add attack animation offset
        if self.attack_animation > 0:
            offset_x = 5 * math.sin(self.attack_animation * 0.2)
            
        # Add hit reaction
        if self.hit_animation > 0:
            offset_x = random.randint(-2, 2)
            offset_y = random.randint(-2, 2)
        
        x = self.x + offset_x
        y = self.y + offset_y
        
        # Draw detailed enemy based on type
        if self.enemy_type == "fiery":
            # Fiery Demon
            pygame.draw.ellipse(surface, (200, 50, 0), (x, y, self.size, self.size))
            # Flames - animate when attacking
            flame_size = 15
            if self.attack_animation > 0:
                flame_size = 20 * (1 - self.attack_animation / 10)
            for i in range(8):
                angle = i * math.pi / 4
                flame_x = x + self.size//2 + math.cos(angle) * flame_size
                flame_y = y + self.size//2 + math.sin(angle) * flame_size
                pygame.draw.polygon(surface, (255, 150, 0), 
                                  [(x + self.size//2, y + self.size//2),
                                   (flame_x, flame_y),
                                   (flame_x + math.cos(angle+0.3)*5, flame_y + math.sin(angle+0.3)*5)])
            # Eyes
            pygame.draw.circle(surface, (255, 255, 0), (x + 15, y + 15), 4)
            pygame.draw.circle(surface, (255, 255, 0), (x + self.size - 15, y + 15), 4)
            # Mouth
            pygame.draw.arc(surface, (255, 100, 0), (x + 10, y + 20, self.size - 20, 15), 0, math.pi, 2)
            
        elif self.enemy_type == "shadow":
            # Shadow Beast
            pygame.draw.ellipse(surface, (40, 40, 80), (x, y, self.size, self.size))
            # Smoky effect - more intense when attacking
            smoke_count = 6
            if self.attack_animation > 0:
                smoke_count = 12 * (1 - self.attack_animation / 10)
            for i in range(int(smoke_count)):
                offset_x = random.randint(-5, 5)
                offset_y = random.randint(-5, 5)
                pygame.draw.circle(surface, (70, 70, 120), 
                                 (x + self.size//2 + offset_x, y + self.size//2 + offset_y), 
                                 random.randint(3, 8))
            # Eyes
            pygame.draw.circle(surface, (0, 255, 255), (x + 15, y + 15), 5)
            pygame.draw.circle(surface, (0, 255, 255), (x + self.size - 15, y + 15), 5)
            # Claws - animate when attacking
            claw_length = 10
            if self.attack_animation > 0:
                claw_length = 15 * (1 - self.attack_animation / 10)
            pygame.draw.line(surface, (0, 200, 200), (x, y + self.size), (x - claw_length, y + self.size + claw_length), 2)
            pygame.draw.line(surface, (0, 200, 200), (x + self.size, y + self.size), (x + self.size + claw_length, y + self.size + claw_length), 2)
            
        else:  # Ice enemy
            # Ice Golem
            pygame.draw.ellipse(surface, (150, 220, 255), (x, y, self.size, self.size))
            # Ice shards - animate when attacking
            shard_length = 20
            if self.attack_animation > 0:
                shard_length = 30 * (1 - self.attack_animation / 10)
            for i in range(8):
                angle = i * math.pi / 4
                shard_x = x + self.size//2 + math.cos(angle) * shard_length
                shard_y = y + self.size//2 + math.sin(angle) * shard_length
                pygame.draw.line(surface, (200, 240, 255), 
                               (x + self.size//2, y + self.size//2),
                               (shard_x, shard_y), 2)
            # Eyes
            pygame.draw.circle(surface, (0, 100, 200), (x + 15, y + 15), 4)
            pygame.draw.circle(surface, (0, 100, 200), (x + self.size - 15, y + 15), 4)
            # Frost breath - animate when attacking
            breath_width = 10
            if self.attack_animation > 0:
                breath_width = 20 * (1 - self.attack_animation / 10)
            pygame.draw.arc(surface, (100, 200, 255), (x + 10, y + 25, self.size - 20, breath_width), 0, math.pi, 2)
            
        # Health bar
        bar_width = 40
        pygame.draw.rect(surface, (20, 20, 30), (x - 5, y - 15, bar_width, 8), border_radius=2)
        health_width = (bar_width - 2) * (self.health / self.max_health)
        pygame.draw.rect(surface, HEALTH_COLOR, (x - 4, y - 14, health_width, 6), border_radius=2)
        
    def update(self, player_x, player_y):
        self.update_animation()
        self.movement_cooldown -= 1
        if self.movement_cooldown <= 0:
            self.movement_cooldown = self.movement_delay
            
            dx, dy = random.choice([(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)])
            new_x = self.x + dx * GRID_SIZE
            new_y = self.y + dy * GRID_SIZE
            
            if 0 <= new_x < SCREEN_WIDTH:
                self.x = new_x
            if 0 <= new_y < SCREEN_HEIGHT:
                self.y = new_y

class Item:
    def __init__(self):
        self.size = ITEM_SIZE
        self.x = random.randint(0, GRID_WIDTH-1) * GRID_SIZE
        self.y = random.randint(0, GRID_HEIGHT-1) * GRID_SIZE
        self.type = random.choice(["health", "mana"])
        self.color = ITEM_COLOR if self.type == "health" else MANA_COLOR
        self.pulse = 0
        self.float_offset = 0
        
    def update(self):
        self.pulse += 0.1
        self.float_offset = math.sin(pygame.time.get_ticks() * 0.003) * 3
        
    def draw(self, surface):
        pulse_size = self.size//2 + math.sin(self.pulse) * 3
        y_pos = self.y + self.float_offset
        
        pygame.draw.circle(surface, self.color, (self.x + self.size//2, y_pos + self.size//2), pulse_size)
        
        if self.type == "health":
            pygame.draw.rect(surface, (255, 255, 255), (self.x + 10, y_pos + 8, 10, 14), border_radius=2)
        else:
            pygame.draw.polygon(surface, (255, 255, 255), 
                              [(self.x + 15, y_pos + 8),
                               (self.x + 8, y_pos + 22),
                               (self.x + 22, y_pos + 22)])

class Dragon:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.animation_frame = 0
        self.fire_frame = 0
        self.fire_active = False
        self.flap_direction = 1
        self.flap_speed = 0.1
        
    def draw(self, surface):
        # Body
        pygame.draw.ellipse(surface, DRAGON_COLOR, (self.x, self.y + 30, 180, 70))
        
        # Head
        pygame.draw.circle(surface, DRAGON_COLOR, (self.x + 180, self.y + 50), 35)
        
        # Eyes
        pygame.draw.circle(surface, (255, 255, 255), (self.x + 195, self.y + 45), 10)
        pygame.draw.circle(surface, (0, 0, 0), (self.x + 195, self.y + 45), 5)
        
        # Horns
        pygame.draw.polygon(surface, (200, 100, 50), [
            (self.x + 180, self.y + 25),
            (self.x + 190, self.y + 10),
            (self.x + 195, self.y + 20)
        ])
        pygame.draw.polygon(surface, (200, 100, 50), [
            (self.x + 205, self.y + 25),
            (self.x + 215, self.y + 10),
            (self.x + 210, self.y + 20)
        ])
        
        # Wings - animate flapping
        wing_y_offset = math.sin(self.animation_frame) * 12
        pygame.draw.polygon(surface, (200, 50, 50), [
            (self.x + 40, self.y + 50),
            (self.x, self.y + 15 + wing_y_offset),
            (self.x + 50, self.y + 30)
        ])
        pygame.draw.polygon(surface, (200, 50, 50), [
            (self.x + 40, self.y + 50),
            (self.x, self.y + 85 - wing_y_offset),
            (self.x + 50, self.y + 70)
        ])
        
        # Tail
        pygame.draw.polygon(surface, DRAGON_COLOR, [
            (self.x, self.y + 50),
            (self.x - 50, self.y + 20),
            (self.x - 50, self.y + 80)
        ])
        
        # Tail spikes
        for i in range(3):
            offset = i * 15
            pygame.draw.polygon(surface, (200, 50, 50), [
                (self.x - 50 + offset, self.y + 50 - offset//2),
                (self.x - 55 + offset, self.y + 40 - offset//2),
                (self.x - 45 + offset, self.y + 40 - offset//2)
            ])
        
        # Fire breath
        if self.fire_active:
            for i in range(15):
                fire_size = 5 + i * 1.5
                alpha = max(0, 200 - i * 10)
                fire_color = (255, 215, 0, alpha)
                
                fire_surf = pygame.Surface((fire_size*2, fire_size*2), pygame.SRCALPHA)
                pygame.draw.circle(fire_surf, fire_color, (fire_size, fire_size), fire_size)
                surface.blit(
                    fire_surf, 
                    (
                        self.x + 180 + 35 + i*15 + self.fire_frame*2, 
                        self.y + 40
                    )
                )
        
        self.animation_frame += self.flap_speed
        
    def breathe_fire(self):
        self.fire_active = True
        self.fire_frame = 0
        
    def update(self):
        if self.fire_active:
            self.fire_frame += 1
            if self.fire_frame > 30:
                self.fire_active = False

class BattleScreen:
    def __init__(self, player, enemy):
        self.player = player
        self.enemy = enemy
        self.state = "player_turn"
        self.battle_log = ["Battle started!", "It's your turn!"]
        self.buttons = [
            Button(50, 450, 180, 50, "ATTACK"),
            Button(250, 450, 180, 50, "MAGIC"),
            Button(450, 450, 180, 50, "ITEM"),
            Button(650, 450, 180, 50, "RUN")
        ]
        self.selected_option = 0
        self.battle_ended = False
        self.result = None
        self.transition_alpha = 0
        self.transition_state = "in"
        self.transition_speed = 8
        self.show_summary = False
        self.damage_effect_timer = 0
        self.damage_target = None
        self.damage_amount = 0
        self.action_cooldown = 0
        self.action_delay = 30
        self.log_page = 0
        self.log_lines_per_page = 3
        self.waiting_for_continue = False
        self.action_steps = []
        self.particle_system = ParticleSystem()
        self.screen_shake = 0
        self.slash_effect = {
            'active': False,
            'x1': 0, 'y1': 0,
            'x2': 0, 'y2': 0,
            'progress': 0,
            'speed': 0.1,
            'color': (255, 255, 255)
        }
        self.magic_effect = {
            'active': False,
            'x': 0, 'y': 0,
            'radius': 0,
            'max_radius': 50,
            'color': MAGIC_COLORS[0]
        }
        
    def start_transition(self):
        self.transition_state = "in"
        self.transition_alpha = 0
        
    def add_screen_shake(self, intensity=5, duration=10):
        self.screen_shake = duration
        self.shake_intensity = intensity
        
    def draw(self, surface):
        # Handle screen shake
        shake_offset_x = 0
        shake_offset_y = 0
        if self.screen_shake > 0:
            shake_offset_x = random.randint(-self.shake_intensity, self.shake_intensity)
            shake_offset_y = random.randint(-self.shake_intensity, self.shake_intensity)
            self.screen_shake -= 1
        
        # Create a temporary surface for all drawing
        temp_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        temp_surface.fill((20, 10, 40))
        
        # --- Detailed Player Avatar ---
        player_x, player_y = 200 + shake_offset_x, 300 + shake_offset_y
        shield_surf = pygame.Surface((PLAYER_SIZE+24, PLAYER_SIZE+24), pygame.SRCALPHA)
        pygame.draw.ellipse(shield_surf, (0, 255, 255, 80), (0, 0, PLAYER_SIZE+24, PLAYER_SIZE+24))
        temp_surface.blit(shield_surf, (player_x-12, player_y-12))
        
        # Draw character based on type with more detail
        if self.player.type == "Warrior":
            # Helmet
            pygame.draw.rect(temp_surface, (0, 100, 0), (player_x + 15, player_y - 10, 20, 15))
            pygame.draw.rect(temp_surface, (0, 150, 0), (player_x + 10, player_y + 5, 30, 5))
            # Body armor
            pygame.draw.rect(temp_surface, (0, 120, 0), (player_x, player_y + 10, 50, 40))
            # Shield
            pygame.draw.rect(temp_surface, (150, 75, 0), (player_x - 15, player_y + 15, 10, 30))
            pygame.draw.circle(temp_surface, (200, 150, 0), (player_x - 10, player_y + 30), 5)
            # Sword
            sword_x = player_x + 50
            sword_y = player_y + 15
            pygame.draw.rect(temp_surface, (200, 200, 200), (sword_x, sword_y, 30, 5))
            pygame.draw.rect(temp_surface, (180, 180, 180), (sword_x, sword_y - 5, 5, 15))
            pygame.draw.circle(temp_surface, (220, 220, 100), (sword_x + 2, sword_y + 2), 3)
            # Draw slash effect if active
            if self.slash_effect['active']:
                progress = self.slash_effect['progress']
                x1 = self.slash_effect['x1'] + (self.slash_effect['x2'] - self.slash_effect['x1']) * progress
                y1 = self.slash_effect['y1'] + (self.slash_effect['y2'] - self.slash_effect['y1']) * progress
                pygame.draw.line(temp_surface, self.slash_effect['color'], 
                               (self.slash_effect['x1'], self.slash_effect['y1']),
                               (x1, y1), 3)
            # Legs
            pygame.draw.rect(temp_surface, (0, 80, 0), (player_x + 10, player_y + 50, 10, 30))
            pygame.draw.rect(temp_surface, (0, 80, 0), (player_x + 30, player_y + 50, 10, 30))
            # Face (only eyes visible)
            pygame.draw.circle(temp_surface, (200, 200, 200), (player_x + 20, player_y + 20), 3)
            pygame.draw.circle(temp_surface, (200, 200, 200), (player_x + 30, player_y + 20), 3)
            
        elif self.player.type == "Mage":
            # Hat
            pygame.draw.polygon(temp_surface, (100, 50, 200), 
                              [(player_x + 15, player_y - 5), 
                               (player_x + 35, player_y - 5),
                               (player_x + 25, player_y - 25)])
            # Robe
            pygame.draw.rect(temp_surface, (0, 100, 150), (player_x, player_y, 50, 50))
            # Staff
            staff_x = player_x + 10
            staff_y = player_y
            pygame.draw.line(temp_surface, (180, 150, 100), (staff_x, staff_y), (staff_x, staff_y + 50), 4)
            # Magic orb - draw effect if active
            if self.magic_effect['active']:
                orb_x = staff_x
                orb_y = staff_y
                radius = self.magic_effect['radius']
                max_radius = self.magic_effect['max_radius']
                
                # Draw expanding magic circle
                for i in range(3, 0, -1):
                    r = radius * (i/3)
                    alpha = 150 * (1 - r/max_radius)
                    color = (*self.magic_effect['color'][:3], int(alpha))
                    pygame.draw.circle(temp_surface, color, (orb_x, orb_y), int(r), 2)
                
                # Draw core
                pygame.draw.circle(temp_surface, self.magic_effect['color'], (orb_x, orb_y), 8)
                
                # Draw particles
                if radius > max_radius * 0.5:
                    angle = random.uniform(0, math.pi*2)
                    dist = random.uniform(0, radius)
                    px = orb_x + math.cos(angle) * dist
                    py = orb_y + math.sin(angle) * dist
                    self.particle_system.add_particle(
                        px, py, self.magic_effect['color'],
                        (math.cos(angle) * 0.5, math.sin(angle) * 0.5),
                        3, 30
                    )
            else:
                pygame.draw.circle(temp_surface, (200, 200, 100), (staff_x, staff_y), 8)
            # Face
            pygame.draw.circle(temp_surface, (240, 200, 150), (player_x + 30, player_y + 15), 8)
            pygame.draw.circle(temp_surface, (0, 0, 0), (player_x + 27, player_y + 14), 2)
            pygame.draw.circle(temp_surface, (0, 0, 0), (player_x + 33, player_y + 14), 2)
            pygame.draw.arc(temp_surface, (150, 100, 100), (player_x + 25, player_y + 20, 10, 5), 0, math.pi, 2)
            
        else:  # Rogue
            # Hood
            pygame.draw.polygon(temp_surface, (100, 0, 0), 
                              [(player_x + 10, player_y + 15), 
                               (player_x + 40, player_y + 15),
                               (player_x + 25, player_y - 10)])
            # Body
            pygame.draw.rect(temp_surface, (150, 0, 0), (player_x, player_y + 15, 50, 35))
            # Belt
            pygame.draw.rect(temp_surface, (50, 50, 50), (player_x, player_y + 40, 50, 5))
            # Daggers
            left_dagger_x = player_x + 15
            right_dagger_x = player_x + PLAYER_SIZE - 15
            dagger_y = player_y + 20
            
            # Draw dagger slash effects if active
            if self.slash_effect['active']:
                progress = self.slash_effect['progress']
                # Left dagger
                lx1 = left_dagger_x
                ly1 = dagger_y
                lx2 = lx1 - 30
                ly2 = ly1 - 30
                lx = lx1 + (lx2 - lx1) * progress
                ly = ly1 + (ly2 - ly1) * progress
                pygame.draw.line(temp_surface, self.slash_effect['color'], (lx1, ly1), (lx, ly), 2)
                
                # Right dagger
                rx1 = right_dagger_x
                ry1 = dagger_y
                rx2 = rx1 + 30
                ry2 = ry1 - 30
                rx = rx1 + (rx2 - rx1) * progress
                ry = ry1 + (ry2 - ry1) * progress
                pygame.draw.line(temp_surface, self.slash_effect['color'], (rx1, ry1), (rx, ry), 2)
            else:
                # Normal daggers
                pygame.draw.polygon(temp_surface, (180, 180, 200), 
                                  [(left_dagger_x, dagger_y), 
                                   (left_dagger_x + 5, dagger_y - 5),
                                   (left_dagger_x + 10, dagger_y)])
                pygame.draw.polygon(temp_surface, (180, 180, 200), 
                                  [(right_dagger_x, dagger_y), 
                                   (right_dagger_x - 5, dagger_y - 5),
                                   (right_dagger_x - 10, dagger_y)])
            # Face (only eyes visible)
            pygame.draw.circle(temp_surface, (200, 200, 200), (player_x + 20, player_y + 20), 3)
            pygame.draw.circle(temp_surface, (200, 200, 200), (player_x + 30, player_y + 20), 3)
            # Legs
            pygame.draw.rect(temp_surface, (100, 0, 0), (player_x + 10, player_y + 45, 10, 15))
            pygame.draw.rect(temp_surface, (100, 0, 0), (player_x + 30, player_y + 45, 10, 15))
        
        # --- Detailed Enemy Avatar ---
        enemy_x, enemy_y = 700 + shake_offset_x, 200 + shake_offset_y
        
        if self.enemy.enemy_type == "fiery":
            # Fiery Demon
            pygame.draw.ellipse(temp_surface, (220, 80, 0), (enemy_x, enemy_y, 60, 60))
            # Flames
            for i in range(12):
                angle = i * math.pi / 6
                flame_length = random.randint(10, 20)
                flame_x = enemy_x + 30 + math.cos(angle) * flame_length
                flame_y = enemy_y + 30 + math.sin(angle) * flame_length
                flame_color = random.choice(FIRE_COLORS)
                pygame.draw.line(temp_surface, flame_color, 
                               (enemy_x + 30, enemy_y + 30),
                               (flame_x, flame_y), 3)
            # Eyes
            pygame.draw.circle(temp_surface, (255, 255, 0), (enemy_x + 20, enemy_y + 25), 6)
            pygame.draw.circle(temp_surface, (255, 255, 0), (enemy_x + 40, enemy_y + 25), 6)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 20, enemy_y + 25), 3)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 40, enemy_y + 25), 3)
            # Mouth
            pygame.draw.arc(temp_surface, (255, 50, 0), (enemy_x + 15, enemy_y + 35, 30, 20), 0, math.pi, 3)
            # Horns
            pygame.draw.polygon(temp_surface, (200, 100, 50), [(enemy_x + 15, enemy_y + 10), (enemy_x + 10, enemy_y - 10), (enemy_x + 20, enemy_y + 5)])
            pygame.draw.polygon(temp_surface, (200, 100, 50), [(enemy_x + 45, enemy_y + 10), (enemy_x + 50, enemy_y - 10), (enemy_x + 40, enemy_y + 5)])
            
        elif self.enemy.enemy_type == "shadow":
            # Shadow Beast
            pygame.draw.ellipse(temp_surface, (30, 30, 60), (enemy_x, enemy_y, 60, 60))
            # Smoky aura
            for i in range(10):
                offset_x = random.randint(-10, 10)
                offset_y = random.randint(-10, 10)
                size = random.randint(5, 15)
                alpha = random.randint(50, 150)
                smoke_surf = pygame.Surface((size*2, size*2), pygame.SRCALPHA)
                pygame.draw.circle(smoke_surf, (70, 70, 120, alpha), (size, size), size)
                temp_surface.blit(smoke_surf, (enemy_x + 30 - size + offset_x, enemy_y + 30 - size + offset_y))
            # Eyes
            pygame.draw.circle(temp_surface, (0, 255, 255), (enemy_x + 20, enemy_y + 25), 7)
            pygame.draw.circle(temp_surface, (0, 255, 255), (enemy_x + 40, enemy_y + 25), 7)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 20, enemy_y + 25), 3)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 40, enemy_y + 25), 3)
            # Mouth
            pygame.draw.arc(temp_surface, (0, 150, 200), (enemy_x + 15, enemy_y + 35, 30, 20), 0, math.pi, 3)
            # Claws
            pygame.draw.line(temp_surface, (0, 200, 200), (enemy_x, enemy_y + 60), (enemy_x - 10, enemy_y + 70), 3)
            pygame.draw.line(temp_surface, (0, 200, 200), (enemy_x + 60, enemy_y + 60), (enemy_x + 70, enemy_y + 70), 3)
            
        else:  # Ice enemy
            # Ice Golem
            pygame.draw.ellipse(temp_surface, (180, 230, 255), (enemy_x, enemy_y, 60, 60))
            # Ice crystals
            for i in range(8):
                angle = i * math.pi / 4
                crystal_length = random.randint(10, 20)
                crystal_x = enemy_x + 30 + math.cos(angle) * crystal_length
                crystal_y = enemy_y + 30 + math.sin(angle) * crystal_length
                pygame.draw.line(temp_surface, (220, 240, 255), 
                               (enemy_x + 30, enemy_y + 30),
                               (crystal_x, crystal_y), 3)
            # Eyes
            pygame.draw.circle(temp_surface, (0, 100, 200), (enemy_x + 20, enemy_y + 25), 6)
            pygame.draw.circle(temp_surface, (0, 100, 200), (enemy_x + 40, enemy_y + 25), 6)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 20, enemy_y + 25), 2)
            pygame.draw.circle(temp_surface, (0, 0, 0), (enemy_x + 40, enemy_y + 25), 2)
            # Mouth
            pygame.draw.arc(temp_surface, (100, 180, 255), (enemy_x + 15, enemy_y + 35, 30, 20), 0, math.pi, 3)
            # Frost breath
            breath_y = enemy_y + 55
            for i in range(5):
                pygame.draw.circle(temp_surface, (200, 240, 255, 150), (enemy_x + 15 + i*7, breath_y), 3)
        
        # Draw health bars
        player_health_width = 150 * (self.player.health / max(1, self.player.max_health))
        enemy_health_width = 150 * (self.enemy.health / max(1, self.enemy.max_health))
        
        pygame.draw.rect(temp_surface, (30, 30, 50), (180, 360, 160, 20))
        pygame.draw.rect(temp_surface, HEALTH_COLOR, (182, 362, player_health_width, 16))
        
        pygame.draw.rect(temp_surface, (30, 30, 50), (680, 260, 160, 20))
        pygame.draw.rect(temp_surface, HEALTH_COLOR, (682, 262, enemy_health_width, 16))
        
        player_text = font_small.render(f"{self.player.health}/{self.player.max_health}", True, TEXT_COLOR)
        text_rect = player_text.get_rect(center=(180 + 80, 360 + 10))
        temp_surface.blit(player_text, text_rect)
        
        enemy_text = font_small.render(f"{self.enemy.health}/{self.enemy.max_health}", True, TEXT_COLOR)
        text_rect = enemy_text.get_rect(center=(680 + 80, 260 + 10))
        temp_surface.blit(enemy_text, text_rect)
        
        # Draw battle log
        pygame.draw.rect(temp_surface, UI_BG, (100, 50, 800, 100), border_radius=8)
        pygame.draw.rect(temp_surface, UI_BORDER, (100, 50, 800, 100), 3, border_radius=8)
        
        start_idx = max(0, len(self.battle_log) - self.log_lines_per_page)
        end_idx = min(len(self.battle_log), start_idx + self.log_lines_per_page)
        
        for i, log in enumerate(self.battle_log[start_idx:end_idx]):
            log_text = font_small.render(log, True, TEXT_COLOR)
            temp_surface.blit(log_text, (120, 70 + i * 30))
        
        # Show "Continue..." message if needed
        if self.waiting_for_continue:
            continue_text = font_small.render("(Press ENTER to continue...)", True, (255, 215, 0))
            temp_surface.blit(continue_text, (120, 70 + self.log_lines_per_page * 30))
        
        # Draw buttons (only if it's player's turn and not waiting)
        if self.state == "player_turn" and not self.waiting_for_continue:
            for i, button in enumerate(self.buttons):
                button.selected = (i == self.selected_option)
                button.draw(temp_surface)
        
        # Draw damage effect
        if self.damage_effect_timer > 0:
            effect_surf = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            if self.damage_target == "player":
                pygame.draw.rect(effect_surf, (255, 0, 0, 100), (player_x, player_y, PLAYER_SIZE, PLAYER_SIZE))
            elif self.damage_target == "enemy":
                pygame.draw.rect(effect_surf, (255, 0, 0, 100), (enemy_x, enemy_y, ENEMY_SIZE, ENEMY_SIZE))
            
            damage_text = font_medium.render(f"-{self.damage_amount}", True, (255, 50, 50))
            if self.damage_target == "player":
                temp_surface.blit(damage_text, (player_x + 20, player_y - 30))
            elif self.damage_target == "enemy":
                temp_surface.blit(damage_text, (enemy_x + 20, enemy_y - 30))
                
            temp_surface.blit(effect_surf, (0, 0))
            self.damage_effect_timer -= 1
        
        # Draw particles
        self.particle_system.draw(temp_surface)
        
        # Draw transition overlay if active
        if self.transition_state != "none":
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, self.transition_alpha))
            temp_surface.blit(overlay, (0, 0))
            
        # Show summary after battle
        if self.battle_ended and self.show_summary:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            temp_surface.blit(overlay, (0, 0))
            
            if self.result == "win":
                summary = [
                    "VICTORY!",
                    f"EXP GAINED: 25",
                    f"KILLS: {self.player.kills}",
                    "Press ENTER to continue..."
                ]
            elif self.result == "lose":
                summary = [
                    "DEFEAT...",
                    "Press ENTER to continue..."
                ]
            elif self.result == "escape":
                summary = [
                    "You Escaped!",
                    "Press ENTER to continue..."
                ]
                
            for i, line in enumerate(summary):
                text = font_large.render(line, True, TEXT_COLOR)
                temp_surface.blit(text, (SCREEN_WIDTH//2 - text.get_width()//2, 250 + i*60))
        
        # Draw the temporary surface to the screen
        surface.blit(temp_surface, (0, 0))

    def update(self):
        # Update animations and effects
        self.player.update_animation()
        self.enemy.update_animation()
        self.particle_system.update()
        
        # Update slash effect
        if self.slash_effect['active']:
            self.slash_effect['progress'] += self.slash_effect['speed']
            if self.slash_effect['progress'] >= 1:
                self.slash_effect['active'] = False
                self.slash_effect['progress'] = 0
                
        # Update magic effect
        if self.magic_effect['active']:
            self.magic_effect['radius'] += 3
            if self.magic_effect['radius'] > self.magic_effect['max_radius']:
                self.magic_effect['active'] = False
                self.magic_effect['radius'] = 0
        
        if self.transition_state == "in":
            self.transition_alpha += self.transition_speed
            if self.transition_alpha >= 255:
                self.transition_alpha = 255
                self.transition_state = "out"
        elif self.transition_state == "out":
            self.transition_alpha -= self.transition_speed
            if self.transition_alpha <= 0:
                self.transition_alpha = 0
                self.transition_state = "none"
                
        if self.action_cooldown > 0:
            self.action_cooldown -= 1
            return False
        
        # Check for battle end conditions
        if self.enemy.health <= 0:
            self.battle_ended = True
            self.result = "win"
            self.add_log("You defeated the enemy!")
            self.show_summary = True
            return True
        elif self.player.health <= 0:
            self.battle_ended = True
            self.result = "lose"
            self.add_log("You were defeated...")
            self.show_summary = True
            return True
        
        # Process current action steps
        if self.action_steps:
            step = self.action_steps.pop(0)
            step()
            return False
            
        # Handle enemy turn if no actions are queued
        if self.state == "enemy_turn" and not self.battle_ended and not self.waiting_for_continue:
            damage = max(1, self.enemy.strength - self.player.defense // 3)
            self.player.health -= damage
            self.add_log(f"Enemy attacks for {damage} damage!")
            self.damage_target = "player"
            self.damage_amount = damage
            self.damage_effect_timer = 20
            self.enemy.start_attack_animation()
            self.player.start_hit_animation()
            self.add_screen_shake(3, 5)
            self.state = "player_turn"
            self.add_log("It's your turn!")
            self.action_cooldown = self.action_delay
            
        return False
    
    def add_log(self, message):
        self.battle_log.append(message)
        self.waiting_for_continue = True
    
    def handle_input(self, event):
        # Handle log continuation
        if self.waiting_for_continue:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                self.waiting_for_continue = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.waiting_for_continue = False
            return
            
        if self.battle_ended and self.show_summary:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                self.show_summary = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.show_summary = False
        elif self.state == "player_turn" and not self.battle_ended and self.action_cooldown == 0:
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RIGHT:
                    self.selected_option = (self.selected_option + 1) % 4
                elif event.key == pygame.K_LEFT:
                    self.selected_option = (self.selected_option - 1) % 4
                elif event.key == pygame.K_UP:
                    self.selected_option = (self.selected_option - 2) % 4
                elif event.key == pygame.K_DOWN:
                    self.selected_option = (self.selected_option + 2) % 4
                elif event.key == pygame.K_RETURN or event.key == pygame.K_SPACE:
                    self.handle_action()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                for i, button in enumerate(self.buttons):
                    if button.rect.collidepoint(mouse_pos):
                        self.selected_option = i
                        self.handle_action()
    
    def handle_action(self):
        if self.state != "player_turn" or self.battle_ended or self.action_cooldown > 0:
            return
            
        if self.selected_option == 0:  # Attack
            self.action_steps = [
                lambda: self.add_log("You attack!"),
                lambda: self.start_attack_animation(),
                lambda: self.execute_attack()
            ]
            
        elif self.selected_option == 1:  # Magic
            if self.player.mana >= 20:
                self.action_steps = [
                    lambda: self.add_log("You cast a fireball!"),
                    lambda: self.start_magic_animation(),
                    lambda: self.execute_magic()
                ]
            else:
                self.add_log("Not enough mana!")
                
        elif self.selected_option == 2:  # Item
            self.action_steps = [
                lambda: self.add_log("You used a health potion!"),
                lambda: self.execute_item()
            ]
            
        elif self.selected_option == 3:  # Run
            self.action_steps = [
                lambda: self.add_log("You attempt to escape..."),
                lambda: self.execute_run()
            ]
    
    def start_attack_animation(self):
        self.player.start_attack_animation()
        
        # Set up slash effect based on character type
        if self.player.type == "Warrior":
            self.slash_effect = {
                'active': True,
                'x1': 200 + 50 + 30,  # Player x + sword x
                'y1': 300 + 15,       # Player y + sword y
                'x2': 700 + 30,       # Enemy x + center
                'y2': 200 + 30,       # Enemy y + center
                'progress': 0,
                'speed': 0.2,
                'color': (255, 255, 200)
            }
        elif self.player.type == "Rogue":
            self.slash_effect = {
                'active': True,
                'x1': 200 + 15,       # Left dagger x
                'y1': 300 + 20,       # Left dagger y
                'x2': 200 + 15 - 30,  # Left dagger slash end
                'y2': 300 + 20 - 30,  # Left dagger slash end
                'progress': 0,
                'speed': 0.3,
                'color': (255, 255, 200)
            }
    
    def start_magic_animation(self):
        self.player.start_attack_animation()
        self.magic_effect = {
            'active': True,
            'x': 200 + 10,  # Staff top x
            'y': 300,       # Staff top y
            'radius': 0,
            'max_radius': 100,
            'color': random.choice(MAGIC_COLORS)
        }
        
        # Add initial magic particles
        for _ in range(20):
            angle = random.uniform(0, math.pi*2)
            dist = random.uniform(0, 10)
            px = self.magic_effect['x'] + math.cos(angle) * dist
            py = self.magic_effect['y'] + math.sin(angle) * dist
            self.particle_system.add_particle(
                px, py, self.magic_effect['color'],
                (math.cos(angle) * 0.5, math.sin(angle) * 0.5),
                3, 30
            )
    
    def execute_attack(self):
        damage = self.player.strength
        self.enemy.health -= damage
        self.add_log(f"You dealt {damage} damage!")
        self.damage_target = "enemy"
        self.damage_amount = damage
        self.damage_effect_timer = 20
        self.enemy.start_hit_animation()
        self.add_screen_shake(5, 8)
        
        # Add hit particles
        if self.enemy.enemy_type == "fiery":
            self.particle_system.add_explosion(
                700 + 30, 200 + 30, FIRE_COLORS[0], 
                count=30, size_range=(2, 6), speed_range=(1, 4), lifetime_range=(15, 30)
            )
        elif self.enemy.enemy_type == "shadow":
            self.particle_system.add_explosion(
                700 + 30, 200 + 30, SHADOW_COLORS[1], 
                count=20, size_range=(3, 8), speed_range=(0.5, 2), lifetime_range=(20, 40)
            )
        else:  # Ice
            self.particle_system.add_explosion(
                700 + 30, 200 + 30, ICE_COLORS[2], 
                count=25, size_range=(2, 5), speed_range=(1, 3), lifetime_range=(15, 25)
            )
        
        self.state = "enemy_turn"
        self.action_cooldown = self.action_delay
    
    def execute_magic(self):
        damage = self.player.strength * 2
        self.enemy.health -= damage
        self.player.mana -= 20
        self.add_log(f"Fireball dealt {damage} damage!")
        self.damage_target = "enemy"
        self.damage_amount = damage
        self.damage_effect_timer = 20
        self.enemy.start_hit_animation()
        self.add_screen_shake(8, 10)
        
        # Create magic beam effect
        self.particle_system.add_beam(
            200 + 10, 300,  # Staff top
            700 + 30, 200 + 30,  # Enemy center
            self.magic_effect['color'], width=5, particle_count=15, speed=3
        )
        
        # Add impact explosion
        self.particle_system.add_explosion(
            700 + 30, 200 + 30, self.magic_effect['color'],
            count=40, size_range=(3, 7), speed_range=(1, 5), lifetime_range=(15, 30)
        )
        
        self.state = "enemy_turn"
        self.action_cooldown = self.action_delay
    
    def execute_item(self):
        heal_amount = 30
        self.player.health = min(self.player.max_health, self.player.health + heal_amount)
        self.add_log(f"Restored {heal_amount} HP!")
        
        # Healing particles
        for _ in range(20):
            x = random.randint(200, 200 + PLAYER_SIZE)
            y = random.randint(300, 300 + PLAYER_SIZE)
            self.particle_system.add_particle(
                x, y, HEALTH_COLOR,
                (random.uniform(-0.5, 0.5), random.uniform(-1, -0.5)),
                3, 30
            )
        
        self.state = "enemy_turn"
        self.action_cooldown = self.action_delay
    
    def execute_run(self):
        if random.random() < 0.7:
            self.add_log("You successfully escaped!")
            self.battle_ended = True
            self.result = "escape"
            self.show_summary = True
        else:
            self.add_log("Escape failed!")
            self.state = "enemy_turn"
            self.action_cooldown = self.action_delay

class Game:
    def __init__(self):
        self.state = "start_menu"
        self.player = None
        self.enemies = []
        self.items = []
        self.score = 0
        self.game_time = 0
        self.spawn_timer = 0
        self.item_timer = 0
        self.starfield = []
        self.dragon = Dragon(SCREEN_WIDTH//2 - 250, SCREEN_HEIGHT//2 - 120)
        self.fire_timer = 0
        self.battle_screen = None
        self.transition_alpha = 0
        self.transition_state = "none"
        self.transition_speed = 10
        self.player_moved = False
        self.movement_cooldown = 0
        self.movement_delay = 10
        self.particle_system = ParticleSystem()
        
        # Initialize starfield
        for _ in range(150):
            self.starfield.append([
                random.randint(0, SCREEN_WIDTH),
                random.randint(0, SCREEN_HEIGHT),
                random.random() * 2 + 0.5
            ])
        
        # Add flying dragons
        self.flying_dragons = []
        for _ in range(5):
            self.flying_dragons.append({
                'x': random.randint(-200, SCREEN_WIDTH),
                'y': random.randint(0, SCREEN_HEIGHT),
                'speed': random.uniform(0.5, 2.0),
                'size': random.randint(2, 5),
                'flap': random.random() * 2 * math.pi
            })
        
        # UI Elements
        self.start_button = Button(SCREEN_WIDTH//2 - 120, 500, 240, 60, "START QUEST", UI_BORDER)
        self.quit_button = Button(SCREEN_WIDTH//2 - 120, 580, 240, 60, "QUIT", UI_BORDER)
        self.back_button = Button(20, 20, 100, 40, "BACK")
        
        # Character buttons
        self.warrior_button = Button(SCREEN_WIDTH//2 - 300, 300, 200, 150, "WARRIOR", (0, 255, 0))
        self.mage_button = Button(SCREEN_WIDTH//2 - 50, 300, 200, 150, "MAGE", (0, 200, 255))
        self.rogue_button = Button(SCREEN_WIDTH//2 + 200, 300, 200, 150, "ROGUE", (255, 100, 0))
        
    def spawn_enemy(self):
        if len(self.enemies) < 5:
            self.enemies.append(Enemy(self.player.level))
    
    def spawn_item(self):
        if len(self.items) < 3:
            self.items.append(Item())
    
    def start_transition(self):
        self.transition_state = "in"
        self.transition_alpha = 0
    
    def update(self):
        # Update starfield
        for star in self.starfield:
            star[0] -= star[2]
            if star[0] < 0:
                star[0] = SCREEN_WIDTH
                star[1] = random.randint(0, SCREEN_HEIGHT)
        
        # Update flying dragons
        for dragon in self.flying_dragons:
            dragon['x'] += dragon['speed']
            dragon['flap'] += 0.05
            if dragon['x'] > SCREEN_WIDTH + 50:
                dragon['x'] = -50
                dragon['y'] = random.randint(0, SCREEN_HEIGHT)
                dragon['speed'] = random.uniform(0.5, 2.0)
        
        # Update particles
        self.particle_system.update()
        
        # Handle transition
        if self.transition_state == "in":
            self.transition_alpha += self.transition_speed
            if self.transition_alpha >= 255:
                self.transition_alpha = 255
                self.transition_state = "out"
        elif self.transition_state == "out":
            self.transition_alpha -= self.transition_speed
            if self.transition_alpha <= 0:
                self.transition_alpha = 0
                self.transition_state = "none"
        
        if self.state == "start_menu":
            self.dragon.update()
            self.fire_timer += 1
            if self.fire_timer > 120:
                self.dragon.breathe_fire()
                self.fire_timer = 0
                
        elif self.state == "overworld" and self.player:
            self.game_time += 1
            self.spawn_timer += 1
            self.item_timer += 1
            self.movement_cooldown = max(0, self.movement_cooldown - 1)
            
            # Update player animation
            self.player.update_animation()
            
            # Update items
            for item in self.items:
                item.update()
            
            if self.spawn_timer >= 300:
                self.spawn_enemy()
                self.spawn_timer = 0
                
            if self.item_timer >= 600:
                self.spawn_item()
                self.item_timer = 0
                
            for enemy in self.enemies:
                enemy.update(self.player.x, self.player.y)
                enemy.update_animation()
                
            for enemy in self.enemies[:]:
                player_rect = pygame.Rect(self.player.x, self.player.y, PLAYER_SIZE, PLAYER_SIZE)
                enemy_rect = pygame.Rect(enemy.x, enemy.y, ENEMY_SIZE, ENEMY_SIZE)
                
                if player_rect.colliderect(enemy_rect):
                    self.battle_screen = BattleScreen(self.player, enemy)
                    self.battle_screen.start_transition()
                    self.state = "battle"
                    self.enemies.remove(enemy)
                    self.player_moved = False
                    break
                    
            for item in self.items[:]:
                item_rect = pygame.Rect(item.x, item.y, ITEM_SIZE, ITEM_SIZE)
                player_rect = pygame.Rect(self.player.x, self.player.y, PLAYER_SIZE, PLAYER_SIZE)
                
                if player_rect.colliderect(item_rect):
                    if item.type == "health":
                        self.player.health = min(self.player.max_health, self.player.health + 30)
                        # Healing particles
                        for _ in range(15):
                            x = random.randint(self.player.x, self.player.x + PLAYER_SIZE)
                            y = random.randint(self.player.y, self.player.y + PLAYER_SIZE)
                            self.particle_system.add_particle(
                                x, y, HEALTH_COLOR,
                                (random.uniform(-0.5, 0.5), random.uniform(-1, -0.5)),
                                3, 30
                            )
                    else:
                        self.player.mana = min(self.player.max_mana, self.player.mana + 40)
                        # Mana particles
                        for _ in range(15):
                            x = random.randint(self.player.x, self.player.x + PLAYER_SIZE)
                            y = random.randint(self.player.y, self.player.y + PLAYER_SIZE)
                            self.particle_system.add_particle(
                                x, y, MANA_COLOR,
                                (random.uniform(-0.5, 0.5), random.uniform(-1, -0.5)),
                                3, 30
                            )
                    self.player.items_collected += 1
                    self.items.remove(item)
    
    def draw(self, screen):
        screen.fill(BACKGROUND)
        
        # Draw starfield background
        for x, y, speed in self.starfield:
            alpha = min(255, int(speed * 100))
            pygame.draw.circle(screen, (200, 200, 255, alpha), (int(x), int(y)), 1)
        
        # Draw flying dragons
        for dragon in self.flying_dragons:
            wing_offset = math.sin(dragon['flap']) * dragon['size']
            color = (200, 200, 255, min(255, int(dragon['size'] * 40)))
            
            pygame.draw.line(
                screen, color,
                (dragon['x'], dragon['y']),
                (dragon['x'] + 5 * dragon['size'], dragon['y']),
                max(1, dragon['size'] // 2)
            )
            
            pygame.draw.line(
                screen, color,
                (dragon['x'] + 2 * dragon['size'], dragon['y']),
                (dragon['x'] + dragon['size'], dragon['y'] - 3 * dragon['size'] - wing_offset),
                max(1, dragon['size'] // 2)
            )
            pygame.draw.line(
                screen, color,
                (dragon['x'] + 2 * dragon['size'], dragon['y']),
                (dragon['x'] + dragon['size'], dragon['y'] + 3 * dragon['size'] + wing_offset),
                max(1, dragon['size'] // 2)
            )
            
            pygame.draw.line(
                screen, color,
                (dragon['x'] + 5 * dragon['size'], dragon['y']),
                (dragon['x'] + 7 * dragon['size'], dragon['y'] - dragon['size']),
                max(1, dragon['size'] // 2)
            )
            
            pygame.draw.line(
                screen, color,
                (dragon['x'], dragon['y']),
                (dragon['x'] - 2 * dragon['size'], dragon['y'] + dragon['size']),
                max(1, dragon['size'] // 2)
            )
        
        if self.state == "start_menu":
            if self.start_button.text != "START QUEST":
                self.start_button.text = "START QUEST"
                self.start_button.text_surf = font_medium.render(self.start_button.text, True, TEXT_COLOR)
                self.start_button.text_rect = self.start_button.text_surf.get_rect(center=self.start_button.rect.center)
            
            title = font_large.render("DRAGON'S LAIR", True, (255, 50, 50))
            screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 80))
            
            subtitle = font_medium.render("A RETRO RPG ADVENTURE", True, TEXT_COLOR)
            screen.blit(subtitle, (SCREEN_WIDTH//2 - subtitle.get_width()//2, 140))
            
            self.dragon.draw(screen)
            
            self.start_button.draw(screen)
            self.quit_button.draw(screen)
            
            instructions = [
                "SELECT YOUR HERO AND EMBARK ON A QUEST",
                "DEFEAT THE DRAGON'S MINIONS AND SURVIVE!",
                "",
                "CONTROLS:",
                "ARROWS/WASD - MOVE",
                "ENTER - SELECT",
                "ESC - QUIT"
            ]
            
            for i, line in enumerate(instructions):
                text = font_tiny.render(line, True, TEXT_COLOR)
                screen.blit(text, (SCREEN_WIDTH//2 - text.get_width()//2, 350 + i*25))
            
        elif self.state == "character_select":
            title = font_large.render("CHOOSE YOUR HERO", True, TEXT_COLOR)
            screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 100))
            
            warrior_desc = [
                "THE WARRIOR",
                "- HIGH HEALTH",
                "- STRONG ATTACKS",
                "- GOOD DEFENSE",
                "- MEDIUM SPEED"
            ]
            
            mage_desc = [
                "THE MAGE",
                "- HIGH MANA",
                "- MAGIC ATTACKS",
                "- LOW DEFENSE",
                "- MEDIUM SPEED"
            ]
            
            rogue_desc = [
                "THE ROGUE",
                "- BALANCED STATS",
                "- QUICK ATTACKS",
                "- AVERAGE DEFENSE",
                "- HIGH SPEED"
            ]
            
            y_pos = 480
            for line in warrior_desc:
                text = font_tiny.render(line, True, (0, 255, 0))
                screen.blit(text, (SCREEN_WIDTH//2 - 300, y_pos))
                y_pos += 25
            
            y_pos = 480
            for line in mage_desc:
                text = font_tiny.render(line, True, (0, 200, 255))
                screen.blit(text, (SCREEN_WIDTH//2 - 50, y_pos))
                y_pos += 25
            
            y_pos = 480
            for line in rogue_desc:
                text = font_tiny.render(line, True, (255, 100, 0))
                screen.blit(text, (SCREEN_WIDTH//2 + 200, y_pos))
                y_pos += 25
            
            self.warrior_button.draw(screen)
            self.mage_button.draw(screen)
            self.rogue_button.draw(screen)
            self.back_button.draw(screen)
            
        elif self.state == "overworld" and self.player:
            for x in range(0, SCREEN_WIDTH, GRID_SIZE):
                pygame.draw.line(screen, GRID_COLOR, (x, 0), (x, SCREEN_HEIGHT), 1)
            for y in range(0, SCREEN_HEIGHT, GRID_SIZE):
                pygame.draw.line(screen, GRID_COLOR, (0, y), (SCREEN_WIDTH, y), 1)
                
            for item in self.items:
                item.draw(screen)
                
            for enemy in self.enemies:
                enemy.draw(screen)
            
            self.player.draw(screen)
            
            # Draw particles
            self.particle_system.draw(screen)
            
            pygame.draw.rect(screen, UI_BG, (10, 10, 250, 130), border_radius=8)
            pygame.draw.rect(screen, UI_BORDER, (10, 10, 250, 130), 3, border_radius=8)
            
            self.player.draw_stats(screen, 20, 20)
            
            score_text = font_medium.render(f"SCORE: {self.score}", True, TEXT_COLOR)
            screen.blit(score_text, (SCREEN_WIDTH - score_text.get_width() - 20, 20))
            
            time_text = font_small.render(f"TIME: {self.game_time//FPS}s", True, TEXT_COLOR)
            screen.blit(time_text, (SCREEN_WIDTH - time_text.get_width() - 20, 60))
            
            kills_text = font_small.render(f"KILLS: {self.player.kills}", True, TEXT_COLOR)
            screen.blit(kills_text, (SCREEN_WIDTH - kills_text.get_width() - 20, 90))
            
            controls = [
                "CONTROLS:",
                "ARROWS/WASD - MOVE",
                "ENTER - SELECT",
                "ESC - MENU"
            ]
            
            for i, line in enumerate(controls):
                text = font_tiny.render(line, True, (180, 180, 200))
                screen.blit(text, (20, SCREEN_HEIGHT - 140 + i * 25))
            
        elif self.state == "battle" and self.battle_screen:
            self.battle_screen.draw(screen)
            
        elif self.state == "game_over" and self.player:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 200))
            screen.blit(overlay, (0, 0))
            
            title = font_large.render("GAME OVER", True, (255, 50, 50))
            screen.blit(title, (SCREEN_WIDTH//2 - title.get_width()//2, 150))
            
            stats = [
                f"HERO: {self.player.type}",
                f"LEVEL: {self.player.level}",
                f"SCORE: {self.score}",
                f"KILLS: {self.player.kills}",
                f"ITEMS: {self.player.items_collected}",
                f"TIME: {self.game_time//FPS} SECONDS"
            ]
            
            y_pos = 220
            for stat in stats:
                text = font_medium.render(stat, True, TEXT_COLOR)
                screen.blit(text, (SCREEN_WIDTH//2 - text.get_width()//2, y_pos))
                y_pos += 40
                
            self.start_button.text = "PLAY AGAIN"
            self.start_button.rect = pygame.Rect(SCREEN_WIDTH//2 - 120, y_pos + 20, 240, 60)
            self.start_button.text_surf = font_medium.render(self.start_button.text, True, TEXT_COLOR)
            self.start_button.text_rect = self.start_button.text_surf.get_rect(center=self.start_button.rect.center)
            self.start_button.draw(screen)
            
            self.back_button.rect = pygame.Rect(SCREEN_WIDTH//2 - 120, y_pos + 100, 240, 60)
            self.back_button.text_surf = font_medium.render(self.back_button.text, True, TEXT_COLOR)
            self.back_button.text_rect = self.back_button.text_surf.get_rect(center=self.back_button.rect.center)
            self.back_button.draw(screen)
            
        if self.state in ["character_select", "game_over"]:
            self.back_button.draw(screen)
            
        if self.transition_state != "none":
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, self.transition_alpha))
            screen.blit(overlay, (0, 0))
            
        pygame.display.flip()
    
    def run(self):
        running = True
        
        while running:
            mouse_pos = pygame.mouse.get_pos()
            mouse_click = False
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                    
                if event.type == pygame.MOUSEBUTTONDOWN:
                    mouse_click = True
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.state == "overworld":
                            self.state = "game_over"
                        elif self.state == "game_over":
                            self.state = "start_menu"
                    
                    if self.state == "overworld" and self.player and self.movement_cooldown <= 0:
                        if event.key in [pygame.K_UP, pygame.K_w]:
                            self.player.move(0, -1)
                            self.player_moved = True
                            self.movement_cooldown = self.movement_delay
                        elif event.key in [pygame.K_DOWN, pygame.K_s]:
                            self.player.move(0, 1)
                            self.player_moved = True
                            self.movement_cooldown = self.movement_delay
                        elif event.key in [pygame.K_LEFT, pygame.K_a]:
                            self.player.move(-1, 0)
                            self.player_moved = True
                            self.movement_cooldown = self.movement_delay
                        elif event.key in [pygame.K_RIGHT, pygame.K_d]:
                            self.player.move(1, 0)
                            self.player_moved = True
                            self.movement_cooldown = self.movement_delay
                    
                    if self.state == "battle" and self.battle_screen:
                        self.battle_screen.handle_input(event)
            
            if self.state == "start_menu":
                self.start_button.update(mouse_pos)
                self.quit_button.update(mouse_pos)
                
                if self.start_button.is_clicked(mouse_pos, mouse_click):
                    self.state = "character_select"
                    
                if self.quit_button.is_clicked(mouse_pos, mouse_click):
                    running = False
                    
            elif self.state == "character_select":
                self.warrior_button.update(mouse_pos)
                self.mage_button.update(mouse_pos)
                self.rogue_button.update(mouse_pos)
                self.back_button.update(mouse_pos)
                
                if self.warrior_button.is_clicked(mouse_pos, mouse_click):
                    self.player = Character("Warrior")
                    self.state = "overworld"
                    self.start_game()
                    
                if self.mage_button.is_clicked(mouse_pos, mouse_click):
                    self.player = Character("Mage")
                    self.state = "overworld"
                    self.start_game()
                    
                if self.rogue_button.is_clicked(mouse_pos, mouse_click):
                    self.player = Character("Rogue")
                    self.state = "overworld"
                    self.start_game()
                    
                if self.back_button.is_clicked(mouse_pos, mouse_click):
                    self.state = "start_menu"
                    
            elif self.state == "overworld":
                pass
                    
            elif self.state == "battle":
                battle_ended = self.battle_screen.update()
                
                if battle_ended:
                    if self.battle_screen.result == "win":
                        self.player.kills += 1
                        self.player.gain_exp(25)
                        self.score += 10
                        self.start_transition()
                        self.state = "overworld"
                        self.battle_screen = None
                    elif self.battle_screen.result == "lose":
                        self.state = "game_over"
                        self.battle_screen = None
                    elif self.battle_screen.result == "escape":
                        self.start_transition()
                        self.state = "overworld"
                        self.battle_screen = None
            
            elif self.state == "game_over":
                self.start_button.update(mouse_pos)
                self.back_button.update(mouse_pos)
                
                if self.start_button.is_clicked(mouse_pos, mouse_click):
                    self.state = "character_select"
                    
                if self.back_button.is_clicked(mouse_pos, mouse_click):
                    self.state = "start_menu"
            
            self.update()
            self.draw(screen)
            
            clock.tick(FPS)
            
        pygame.quit()
        sys.exit()
    
    def start_game(self):
        self.enemies = []
        self.items = []
        self.score = 0
        self.game_time = 0
        self.spawn_timer = 0
        self.item_timer = 0
        self.player_moved = False
        self.movement_cooldown = 0
        
        for _ in range(3):
            self.spawn_enemy()
        for _ in range(2):
            self.spawn_item()

if __name__ == "__main__":
    game = Game()
    game.run()